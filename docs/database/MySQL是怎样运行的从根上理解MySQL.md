# 3 第3章 乱码的前世今生-字符集和比较规则
(看书的时候把书中的 mysql 命令找一个测试的 mysql 自己尝试一下)

- utf8mb3 :阉割过的 utf8 字符集，只使用1~3个字节表示字符。 (mysql中 utf8 就是 utf8mb3 的别名)
- utf8mb4 :正宗的 utf8 字符集，使用1~4个字节表示字符。 (如果有 emoji 要用utf8mb4)

字符集(CHARSET)与比较规则(COLLATION)：

- 只修改字符集，则比较规则将变为修改后的字符集默认的比较规则。
- 只修改比较规则，则字符集将变为修改后的比较规则对应的字符集。(比如要修改大小写排序敏感等)

我们通常都把 character_set_client 、character_set_connection、 character_set_results 这三个系统变量设置成和客户端使用的字符集一致的情况，
这样减少了很多无谓的字符 集转换。为了方便我们设置， MySQL 提供了一条非常简便的语句: `SET NAMES 字符集名`;

这一条语句产生的效果和我们执行这3条的效果是一样的:
```
SET character_set_client = 字符集名;
SET character_set_connection = 字符集名;
SET character_set_results = 字符集名;
```

# 4 第4章 从一条记录说起-InnoDB记录结构

页: InnoDB将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小 一般为 16 KB。
也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB 内容刷新到磁盘中。

行格式： Compact 、 Redundant 、Dynamic 和 Compressed 行格式

### 4.3.2 Compact 行格式：

`|变长字段长度列表|NULL值列表|记录头信息|列1的值|列2的值|...|列n的值|`

 MySQL 会为每个记录默认的添加一些列(也称为 隐藏列 ), DB_ROW_ID(没有定义主键和unique键会添加), DB_TRX_ID(事务ID), DB_ROLL_PTR(回滚指针)

对于 CHAR(M) 类型的列来说，当列采用的是定长字符集时，该列占用的字节数不会被加到变长字 段长度列表，而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表。

### 4.3.3 Redundant 行格式

`|字段长度偏移列表|记录头信息|列1的值|列2的值|...|列n的值|`

### 4.3.4 行溢出数据

MySQL 是以 页 为基本单位来管理存储空间的，我们 的记录都会被分配到某个 页 中存储。而一个页的大小一般是 16KB ，
也就是 16384 字节，而一个 VARCHAR(M) 类 型的列就最多可以存储 65532 个字节，这样就可能造成一个页存放不了一条记录的尴尬情况。

4.3.5 Dynamic和Compressed行格式
Dynamic 和 Compressed 行格式 MySQL 版本是 5.7 ，它的默认行格 式就是 Dynamic ，这俩行格式和 Compact 行格式挺像，
只不过在处理 行溢出 数据时有点儿分歧，它们不会在记录的真实数据处存储字段真实数据的前 768 个字节，而是把所有的字节都存储到其他页面中，
只在记录的真实数 据处存储其他页面的地址。

Compressed 行格式和 Dynamic 不同的一点是， Compressed 行格式会采用压缩算法对页面进行压缩，以节省空 间。

# 5 第5章 盛放记录的大盒子-InnoDB数据页结构

## 5.2 数据页结构的快速浏览

数据页代表的这块 16KB 大小的存储空间可以被划分为多个部分，不同部分有不同的功能，InnoB数据页结构示意图：

`|File Header(38字节)|Page Header(56字节)|Infimum + supremum(26字节)|User Records(大小不定)|Free Space(大小不定)|Page Directory(大小不定)|File Tailer(8字节)|`

## 5.3 记录在页中的存储

在一开 始生成页的时候，其实并没有 User Records 这个部分，每当我们插入一条记录，都会从 Free Space 部分，
也就是尚未使用的存储空间中申请一个记录大小的空间划分到 User Records 部分，当 Free Space 部分的空间全部 被 User Records 部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新 的页了

不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表，链表中的各个 节点是按照主键值由小到大的顺序连接起来的

## 5.4 Page Directory (页目录)

所以在一个数据页中查找指定主键值的记录的过程分为两步:
1. 通过二分法确定该记录所在的槽，并找到该槽中主键值最小的那条记录。
2. 通过记录的 next_record 属性遍历该槽所在的组中的各个记录。


## 5.5 Page Header (页面头部)

为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第 一条记录的地址是什么，
页目录中存储了多少个槽等等，特意在页中定义了一个叫 Page Header 的部分，它是页结构的第二部分，
这个部分占用固定的 56 个字节，专门存储各种状态信息

## 5.6 File Header(文件头部)

File Header 针对各种类型的页都通用，也就是说不同类型的页都会以 File Header 作 为第一个组成部分，
它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、 下一个页是谁, 这个部分占用固定的 38 个字节

## 5.7 File Trailer

InnoDB 存储引擎会把数据存储到磁盘上，但是磁盘速度太慢，需要以 页 为单位把数据加载到内存中处理，
如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候中断电了咋办，
为了检测一个页是否完整(也就是在同步的时候有没有发生只同步 一半的尴尬情况)，InnoDB 每个页的尾部都加了一个 File Trailer 部分，
这个部分由 8 个字 节组成，可以分成2个小部分: 前4个字节代表页的校验和, 后4个字节代表页面被最后修改时对应的日志序列位置(LSN)。


# 6 第6章 快速查询的秘籍-B+树索引

## 6.2 索引

页分裂：下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。如果不满足就需要先移动再插入，
这个过程我们也可以称为 页分裂 。

目录项记录和普通用户记录的区别：(一个存储 主键和页号，一个存用户插入数据)

- 目录项记录 的 record_type 值是1，而普通用户记录的 record_type 值是0。
- 目录项记录 只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列， 另外还有 InnoDB 自己添加的隐藏列。
- 只有在存储 目录项记录 的页 中的主键值最小的 目录项记录 的 min_rec_mask 值为 1 ，其他别的记录的 min_rec_mask 值都是 0 。

不论是存放用户记录的数据页，还是存放目录项记录的数据页，我们都把它们存放到 B+ 树这个数据结构中了， 所以我们也称这些数据页为 节点 。
从图中可以看出来，我们的实际用户记录其实都存放在B+树的最底层的节点 上，这些节点也被称为 叶子节点 或 叶节点 ，
其余用来存放 目录项 的节点称为 非叶子节点 或者 内节点 ，其 中 B+ 树最上边的那个节点也称为 根节点 。

#### 6.2.2.1 聚簇索引

上边介绍的 B+ 树本身就是一个目录，或者说本身就是一个索引。它有两个特点:
1. 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义:
    - 页内的记录是按照主键的大小顺序排成一个单向链表。
    - 各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。
    - 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成
    一个双向链表。
2. B+ 树的叶子节点存储的是完整的用户记录。 所谓完整的用户记录，就是指这个记录中存储了所有列的值(包括隐藏列)。

具有这两种特性的 B+ 树称为 聚簇索引 ，所有完整的用户记录都存放在这个 聚簇索引 的叶子节点处
InnoDB 存储引擎会自动的为我们创建聚簇索引。另外有趣的一点是，在 InnoDB 存储引擎中， 聚簇索引 就是数 据的存储方式(所有的用户记录都存储在了 叶子节点 )，
也就是所谓的索引即数据，数据即索引。

#### 6.2.2.2 二级索引

非聚簇索引(二级索引or辅助索引)：B+ 数叶子节点只存储了当前列和主键，还需要再去聚簇索引中再查找一遍完整的用户记录。(这个过程也叫做回表)

联合索引：以多个列的大小为排序规则建立的B+树称为联合索引，本质上也是一个二级索引 (一个B+树)

### 6.2.3 InnoDB的B+树索引的注意事项

- 根节点不动

一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表 建立一个索引，那么它的 根节点 的页号便会被记录到某个地方，
然后凡是 InnoDB 存储引擎需要用到这个索引的 时候，都会从那个固定的地方取出 根节点 的页号，从而来访问这个索引。

- 内节点中目录项记录的唯一性
- 一个页面最少存储2条记录

### 6.2.4 MyISAM中的索引方案简单介绍

- MyISAM 的索引方案虽然也使用树形 结构，但是却将索引和数据分开存储:
将表中的记录按照记录的插入顺序单独存储在一个文件中，称之为 数据文件 。这个文件并不划分为若干个 数据页，有多少记录就往这个文件中塞多少记录就成了。我们可以通过行号而快速访问到一条记录
- 使用 MyISAM 存储引擎的表会把索引信息另外存储到一个称为 索引文件 的另一个文件中。
MyISAM 会单独为 表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是 主键值 + 行号 的组 合。也就是先通过索引找到对应的行号，再通过行号去找对应的记录!(全部是二级索引)
- 如果有需要的话，我们也可以对其它的列分别建立索引或者建立联合索引，原理和 InnoDB 中的索引差不 多，不过在叶子节点处存储的是 相应的列 + 行号 。这些索引也全部都是 二级索引


### 6.2.5 MySQL中创建和删除索引的语句

InnoDB 和 MyISAM 会自动为主键或 者声明为 UNIQUE 的列去自动建立 B+ 树索引，但是如果我们想为其他的列建立索引就需要我们显式的去指明。


# 7 第7章 好东西也得先学会怎么用-B+树索引的使用

## 7.1 索引的代价

- 空间。每建立一个索引都要为它建立一棵 B+ 树，每一棵 B+ 树的每一个节点都是一个数据页， 一个页默认会占用 16KB 的存储空间，一棵很大的 B+ 树由许多数据页组成
- 时间。每次对表中的数据进行增、删、改操作时，都需要去修改各个 B+ 树索引

## 7.2 B+树索引适用的条件

```
-- 以下使用这个表作为示例
CREATE TABLE person_info(
        id INT NOT NULL auto_increment,
        name VARCHAR(100) NOT NULL,
        birthday DATE NOT NULL,
        phone_number CHAR(11) NOT NULL,
        country varchar(100) NOT NULL,
        PRIMARY KEY (id),
        KEY idx_name_birthday_phone_number (name, birthday, phone_number)
);
```

- 全值匹配：搜索条件中的列和索引列一致的话，这种情况就称为全值匹配。
` SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27' AND phone_num ber = '15123983239';`
这几个条件的书写顺序无影响，查询优化器会根据索引顺序决定先使用那个搜索条件。

- 匹配左边的列(最左前缀)。如果我们想使用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中 从最左边连续的列
因为 B+ 树的数据页和记录先是按照 name 列的值排序的，在 name 列的值相同的情况下才使 用 birthday 列进行排序(上述 sql 例子)。

- 匹配列前缀。 `SELECT * FROM person_info WHERE name LIKE 'As%';` 可以使用索引，而 `LIKE %As%` 会全表扫描

- 匹配值范围。B+树所有记录都是按照索引列的值从小到大的顺序排好序的。
    - `SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow'`; 可以使用索引，因为排好序了找到首位记录，
    中间链表连起来的都可以取出来，之后找到记录的主键回表查找完整记录。
    - 如果对多个列同时进行范围查找的话，只有对索引最左边的那个 列进行范围查找的时候才能用到 B+ 树索引。
    `SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow' AND birthday > '1980-01-01'` 只能用到 name 索引

- 精确匹配某一列并范围匹配另外一列。对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精
确查找，则右边的列可以进行范围查找
    - ` SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday > '1980-01-01' AND birthday < '2000-12-31' AND phone_number > '15100000000';`
    - 上面 sql name 和 birthday 可以用到索引，但是 phone_number 条件不行

- 用于排序。
    - ORDER BY 子句里使用到了我们的 索引列，就有可能省去在内存或文件中排序的步骤。`SELECT * FROM person_info ORDER BY name, birthday, phone_number LIMIT 10;`
    - 使用联合索引排序注意：ORDER BY 的子句后边的列的顺序也必须按照索引列的顺序给出
    - 不可以使用索引排序的几种情况：
        - ASC, DESC 混用
        - WHERE 子句中出现非排序使用到的索引列
        - 排序列包含非同一个索引的列。`SELECT * FROM person_info ORDER BY name, country LIMIT 10;` country 不在索引列
        - 排序列使用了复杂表达式

- 用户分组。`SELECT name, birthday, phone_number, COUNT(*) FROM person_info GROUP BY name, birthday, phone_number`

## 7.3 回表的代价

`SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow';` 这个语句两个特点：

- 会使用到两个 B+ 树索引，一个二级索引，一个聚簇索引。
- 访问二级索引使用 顺序I/O ，访问聚簇索引使用 随机I/O 。

覆盖索引：为了彻底告别 回表 操作带来的性能损耗，我们建议:最好在查询列表里只包含索引列，比如这样:
`SELECT name, birthday, phone_number FROM person_info WHERE name > 'Asa' AND name < 'Barlow'`

## 7.4 如何挑选索引

- 只为用于搜索、排序或分组的列创建索引。只为出现在 WHERE 子句中的列、连接子句中的连接列，或者出现在 ORDER BY 或 GROUP BY 子句中的列创建索引。
- 考虑列的基数(值越分散)。 最好为那些列的基数大的列建立索引，为基数 太小列的建立索引效果可能不好。
- 索引列的类型尽量小 。比较更快，占用更小
- 索引字符串值的前缀。只对字符串的前几个字符进行索引
- 让索引列在比较表达式中单独出现。索引列不要加上函数或者表达式，否则索引用不到
- 主键插入顺序。最好让主键具 有 AUTO_INCREMENT ，让存储引擎自己为表生成主键，而不是我们手动插入。
- 冗余和重复索引。比如定义了联合索引，又单独定义了一个列索引。


# 第8章 数据的家-MySQL的数据目录

## 8.2 MySQL数据目录

`SHOW VARIABLES LIKE 'datadir';`

## 8.3 数据目录的结构

每个数据库都对应数据目录下的一个子目录，或者说对应一个文件夹，我们每当我们新建一个数据库 时， MySQL 会帮我们做这两件事儿:

1. 在 数据目录 下创建一个和数据库名同名的子目录(或者说是文件夹)。
2. 在该与数据库名同名的子目录下创建一个名为 db.opt 的文件，这个文件中包含了该数据库的各种属性，比
  方说该数据库的字符集和比较规则是个啥。

表结构信息：InnoDB 和MyISAM 这两种存储引擎都在 数据目录 下对应的数据库子目录下创建了一个专门用于描述表结构的文件。表名.frm

#### 8.3.2.1 InnoDB是如何存储表数据的

- 系统表空间(system tablespace):可以对应文件系统上一个或多个实际的文件，默认情况下， InnoDB 会在 数据目录下创建一个名为
ibdata1 (在你的数据目录下找找看有木有)、大小为 12M 的文件，这个文件就是对应的 系统表空 间 在文件系统上的表示

- 独立表空间(file-per-table tablespace): mysql5.5.6以后每一个表建立一个独立表空间。 test.ibd(自扩展)，存储 test 表的数据和索引

#### 8.3.2.2 MyISAM是如何存储表数据的

MyISAM 全部是二级索引，数据和引擎分开。表数据都存放到对应的数据库子目录下。test.frm, test.MYD(数据文件), test.MYI(索引文件)

### 8.3.3 视图在文件系统中的表示

存储 视图 的时候是不 需要存储真实的数据的，只需要把它的结构存储起来就行了。和 表 一样，
描述视图结构的文件也会被存储到所属数据库对应的子目录下边，只会存储一个 视图名.frm 的文件

## 8.5 MySQL系统数据库简介


- mysql: 存储了MySQL的用户账户和权限信息，一些存储过程、事件的定义信息，一些运行过 程中产生的日志信息，一些帮助信息以及时区信息等
- information_schema: MySQL服务器维护的所有其他数据库的信息，比如有哪些表、哪些视图、哪些触发器、哪 些列、哪些索引
- performance_schema: 这个数据库里主要保存MySQL服务器运行过程中的一些状态信息，算是对MySQL服务器的一个性能监控
- sys: 这个数据库主要是通过视图的形式把 information_schema 和 performance_schema 结合起来，让程序员可以更方便的了解MySQL服务器的一些性能信息。


# 9 第9章 存放页面的大池子-InnoDB的表空间

## 9.2 独立表空间结构

### 9.2.1 区(extent)的概念

对于16KB的页来说，**连续**的64个页就是一个 区 ，也就是说一个区默认占用1MB空间大小。不论是系统 表空间还是独立表空间，
都可以看成是由若干个区组成的，每256个区被划分成一组。每个组的最开始的几个页面类型是固定的。

### 9.2.2 段(segment)的概念

设计 InnoDB 的大叔们对 B+ 树的叶子节点和非叶子节点进行了区别对待，也就是说叶子节点有自己 独有的 区 ，
非叶子节点也有自己独有的 区 。存放叶子节点的区的集合就算是一个 段 ( segment )，存放非叶 子节点的区的集合也算是一个 段 。
也就是说一个索引会生成2个段，一个叶子节点段，一个非叶子节点段。

是碎片区中的页 可以用于不同的目的，比如有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于。碎片区直属于表空 间，
并不属于任何一个段。所以此后为某个段分配存储空间的策略是这样的:

- 在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。
- 当某个段已经占用了32个碎片区页面之后，就会以完整的区为单位来分配存储空间。

### 9.2.3 区的分类

表空间的是由若干个区组成的，这些区大体上可以分为4种类型:
- 空闲的区:现在还没有用到这个区中的任何页面。
- 有剩余空间的碎片区:表示碎片区中还有可用的页面。
- 没有剩余空间的碎片区:表示碎片区中的所有页面都被使用，没有空闲页面。
- 附属于某个段的区。每一个索引都可以分为叶子节点段和非叶子节点段，除此之外InnoDB还会另外定义一些 特殊作用的段，在这些段中的数据量很大时将使用区来作为基本的分配单位。


综上所述，表空间是由若干个区组成的，每个区都对应一个 XDES Entry 的结构，直属于表空间的区对应的 XDES Entry 结构可以分成 
FREE 、 FREE_FRAG 和 FULL_FRAG 这3个链表;每个段可以附属若干个区，每个段中的区对 应的 XDES Entry 结构可以分成 
FREE 、 NOT_FULL 和 FULL 这3个链表。每个链表都对应一个 List Base Node 的 结构，这个结构里记录了链表的头、尾节点的位置以及该链表中包含的节点数。
正是因为这些链表的存在，管理 这些区才变成了一件so easy的事情。

### 9.2.4 段的结构

每个 段都定义了一个 INODE Entry 结构来记录一下段中的属性

### 9.2.5 各类型页面详细情况

### 9.2.6 Segment Header 结构的运用

## 9.3 系统表空间

系统表空间的结构和独立表空间基本类似,只不过整个MySQL进程只有一个系统表空间，在系统表空间中会额外记录一些有关整个系统信息的页面，
所以会比独立表空间多出一些记录这些信息的页面


# 10 第10章 条条大路通罗马-单表访问方法
