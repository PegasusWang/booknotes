# 01 中间件生态（上）：有哪些类型的中间件？

中间件是游离于业务需求之外，专门为了处理项目中涉及高可用、高性能、高并发等技术需求而引入的一个个技术组件。它的一个重要作用就是能够实现业务代码与技术功能之间解耦合。

![](./分布式中间件.png)


# 02 中间件生态（下）：同类型的中间件如何进行选型？

- 本地缓存中间件：Guava Cache 和 Caffeine
- 分布式缓存中间件： Redis, Memcache
- 全文索引中间件：Elasticsearch。场景：一个是宽表、解决跨库 Join，另一个就是全文搜索
  - 分库分表在面对多维度查询时将变得力不从心: 使用数据异构 + 宽表。引入 Canal 数据同步工具，订阅 MySQL 的 Binglog，将增量数据同步到 Elasticsearch 中，实现数据访问层面的读写分离。
- 分布式日志中间件：进行日志采集的机器上安装一个 filebeat 工具，用来采集服务器的日志，并将它们存储到消息中间件中。然后，
  在需要采集的机器中安装 Logstash 进程，通过 Logstash 将日志数据存储到 Elasticsearch 服务器，用户可以通过 Kibana 查询存储在 Elasticsearch 中的日志数据


# 03 数组与链表：存储设计的基石有哪些？

- ArrayList
- LinkedList
- HashMap


# 04 红黑树：图解红黑树的构造过程与应用场景

- TreeMap: 红黑树。 可以用来实现一致性哈希
- LinkedhashMap:  LinkedList 和 HashMap 的结合体。实现 lru
- PriorityQueue: 堆


# 05 多线程：多线程编程有哪些常见的设计模式？

如何复用线程：线程池。内部是 while + 阻塞队列的机制，确保线程的 run 方法不会结束。在有任务执行时运行任务，无任务运行时则通过阻塞队列阻塞线程。

- Future模式

它指的是主线程向另外一个线程提交任务时，无须等待任务执行完毕，而是立即返回一个凭证，也就是 Future。这时主线程还可以做其他的事情，不会阻塞。
等到需要异步执行结果时，主线程调用 Future 的 get 方法，如果异步任务已经执行完毕，则立即获取结果；如果任务还没执行完，则主线程阻塞，等待执行结果。

Future 模式的核心要领是将多个请求进行异步化处理，并且可以得到返回结果。常用线程池的方式实现。

- 生产者、消费者模式


# 06 锁：如何理解锁的同步阻塞队列与条件队列？


# 07 NIO：手撸一个简易的主从多Reactor线程模型

在等待数据阶段，如果发起网络调用后，在服务端数据没有准备好的情况下客户端会阻塞，我们称为阻塞 IO；如果数据没有准备好，但网络调用会立即返回，我们称之为非阻塞 IO。

在数据传输阶段，如果发起网络调用的线程还可以做其他事情，我们称之为异步，否则称之为同步。


BIO 的全称同步阻塞 IO，还有 NIO 的全称同步非阻塞 IO。NIO 模型更适合需要大量在线活跃连接的场景，常见于服务端；BIO 模型则适合只需要支持少量连接的场景。

主从多 Reactor 模型。它的核心设计理念是让线程分工明确，相互协作。Main Reactor 线程池主要负责连接建立，SubReactor 线程池主要负责网络的读写，而编码、解码和业务执行则需要具体情况具体分析。


# 08 Netty：如何优雅地处理网络读写，制定网络通信协议？

经典的协议设计方法是：协议头+ body 的设计理念


# 08 加餐 中间件底层的通用设计理念

数据结构、多线程编程（并发编程）、网络编程（NIO、Netty）、内存管理、文件编程、领域知识
