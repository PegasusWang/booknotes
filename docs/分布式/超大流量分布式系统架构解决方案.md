# 3 . 削峰填谷--流控方案

### 3.1 为何需要限流

- 扩容
- 静态化(cdn)
- 限流
- 缓存
- 队列

CDN(缓存静态数据) -> 读系统(多级缓存) -> 写系统（削峰限流） -> DB

### 3.2 限流方案

池化技术（连接池、线程池、对象池）：通过计数器算法限制全局并发数。

- 令牌桶算法(Token Bucket)
- 漏桶算法(Leaky Bucket)
- 计数器算法: 单位是时间内计数并且和阈值不断比较

Guava 是 google 提供的 Java Api。
Nginx 配置限流 limit_req_zone

### 3.3 基于时间片的削峰方案

- 活动分时间段实现削峰。业务角度，抢购时间段分为多次
- 通过答题验证实现削峰

### 3.4 基于消息队列的解耦、削峰、最终一致性方案


# 4. 大促抢购核心技术难题--读写优化方案

### 4.1 缓存技术简介

- 本地缓存. Java Ehcache。多级缓存。GuavaCache + Redis。
    - 问题：占用系统内存。数据一致性问题
- 分布式缓存

### 4.2 高性能分布式缓存 redis

- hash 算法
- 一致性哈希
- 分槽算法


### 4.3 同一热卖商品高并发读取难题

单点瓶颈，热 key 都落到了同一个 slot 上。

- 多级缓存方案。
    - 本地缓存(localcache)+分布式缓存的多级缓存方案。off-heap手段规避资源占用较高和频繁 GC 等问题。
    - 被动更新: 缓存过期，重新执行回源操作。注意避免失效之后的缓存击穿问题引起雪崩，使用 singleflight 模式或者限制一个线程访问
    - 主动更新：基于消息队列，修改数据后通过消息队列，所有订阅者消费并且更新本地缓存
- RedisCluster 模式一主多从读/写分离方案

缓存穿透，通过日志等，自动上报和发现热点，实施热点保护。

### 4.4 同一热卖商品高并发写难题

Mysql InnoDB 行锁问题。悲观锁(性能差)和乐观锁(增加 version 字段)

在关系数据库之外进行热卖商品的库存扣减操作。使用分布式锁会比较重。有以下两种方式：

- 基于乐观锁实现库存扣减。 WATCH/MULTI/EXEC 命令结合即可实现乐观锁效果。
- 结合 lua 脚本实现库存扣减。 redis执行 EVAL/EVALSHA 把它当做单条命令在执行，操作原子。扣减成功后，可以写入到消息队列实
现削峰，保证写入到数据库的流量可控。

```lua
local sku = KEYS[1] -- 目标 SKU
local num = tonumber(ARGV[1]) -- 需要扣减的数量
local stock = tonumber(redis.call('GET', sku)) -- 获取目标 SKU 的库存
local result = 0
if (stock >= num) then
	redisl.call('DECRBY', sku, num) -- 原子扣减库存
	result = 1
end
return result
```
